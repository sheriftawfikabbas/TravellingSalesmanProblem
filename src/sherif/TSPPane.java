/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

 /*
 * TSPPane.java
 *
 * Created on May 4, 2011, 5:20:52 PM
 */
package sherif;

import java.awt.*;
import java.util.Arrays;
import org.jgap.Gene;
import org.jgap.IChromosome;
import org.jgap.impl.IntegerGene;

/**
 *
 * @author kadersh
 */
public class TSPPane extends javax.swing.JPanel {

    AbstractTSPData data;
    IChromosome route;
    int[] optimalRoute = null;

    /**
     * Creates new form TSPPane
     */
    public TSPPane(AbstractTSPData _data) {
        route = null;
        data = _data;
        initComponents();

    }

    public void setOptimalRoute(int[] optimalRoute) {
        this.optimalRoute = Arrays.copyOf(optimalRoute, data.counter);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed"
	// desc="Generated Code">//GEN-BEGIN:initComponents
	private void initComponents() {

		addMouseListener(new java.awt.event.MouseAdapter() {
			public void mouseReleased(java.awt.event.MouseEvent evt) {
				formMouseReleased(evt);
			}
		});

		javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
		this.setLayout(layout);
		layout.setHorizontalGroup(layout.createParallelGroup(
				javax.swing.GroupLayout.Alignment.LEADING).addGap(0, 400,
				Short.MAX_VALUE));
		layout.setVerticalGroup(layout.createParallelGroup(
				javax.swing.GroupLayout.Alignment.LEADING).addGap(0, 300,
				Short.MAX_VALUE));
	}// </editor-fold>//GEN-END:initComponents

    private void formMouseReleased(java.awt.event.MouseEvent evt) {// GEN-FIRST:event_formMouseReleased

        System.out.println("Coordinates: " + evt.getX() + "," + evt.getY());
        data.coordinateArray[data.counter][0] = evt.getX();
        data.coordinateArray[data.counter][1] = evt.getY();

        // Paint a ball there
        data.counter++;
        repaint();

    }// GEN-LAST:event_formMouseReleased

	// Variables declaration - do not modify//GEN-BEGIN:variables
	// End of variables declaration//GEN-END:variables
	public int max(int a[][], int b) {
        int max_a = a[0][b];
        for (int i = 0; i < a.length; i++) {
            if (a[i][b] > max_a) {
                max_a = a[i][b];
            }
        }
        return max_a;
    }

    public double max(double a[][], int b) {
        double max_a = a[0][b];
        for (int i = 0; i < a.length; i++) {
            if (a[i][b] > max_a) {
                max_a = a[i][b];
            }
        }
        return max_a;
    }

    @Override
    protected void paintComponent(Graphics g) {
        setBackground(Color.green);
        // Ensure proportionality with the panel size: Get maximum x and y
        double proportionalityConstantY = getVisibleRect().getHeight()
                / max(data.coordinateArray, 1);
        double proportionalityConstantX = getVisibleRect().getWidth()
                / max(data.coordinateArray, 0);

        // System.out.println(proportionalityConstantX + ","+
        // proportionalityConstantY + ","+ max(data.coordinateArray, 1));
        if (data != null) {
            super.paintComponent(g);
            for (int i = 0; i < data.counter; i++) {

                g.setColor(Color.WHITE);
                g.fillOval(
                        (int) (data.coordinateArray[i][0] - 15 // * proportionalityConstantX
                        ), (int) (data.coordinateArray[i][1]- 15 // * proportionalityConstantY
                        ), 30, 30);
                g.setColor(Color.RED);
                g.drawString(Integer.toString(i),
                        (int) (data.coordinateArray[i][0] // * proportionalityConstantX
                        ), (int) (data.coordinateArray[i][1] // * proportionalityConstantY
                        ));

            }
        }
        if (optimalRoute != null) {
            for (int i = 0; i < data.counter; i++) {
                if (i < data.counter - 1) {
                    double x1 = data.coordinateArray[optimalRoute[i] - 1][0];
                    double y1 = data.coordinateArray[optimalRoute[i] - 1][1];
                    double x2 = data.coordinateArray[optimalRoute[i + 1] - 1][0];
                    double y2 = data.coordinateArray[optimalRoute[i + 1] - 1][1];

                    g.setColor(Color.BLUE);

                    g.drawLine((int) (proportionalityConstantX * x1),
                            (int) (proportionalityConstantY * y1),
                            (int) (x2 * proportionalityConstantX),
                            (int) (proportionalityConstantY * y2));

                }
            }
        }
        if (route != null) {
            Gene[] routeGene = route.getGenes();
            for (int i = 0; i < routeGene.length; i++) {
                if (i < routeGene.length - 1) {
                    IntegerGene from = (IntegerGene) routeGene[i];
                    IntegerGene to = (IntegerGene) routeGene[i + 1];
                    int intFrom = from.intValue();
                    int intTo = to.intValue();
                    double x1 = data.coordinateArray[intFrom][0];
                    double y1 = data.coordinateArray[intFrom][1];
                    double x2 = data.coordinateArray[intTo][0];
                    double y2 = data.coordinateArray[intTo][1];

                    g.setColor(Color.RED);

                    g.drawLine((int) ( // proportionalityConstantX *
                            x1), (int) ( // proportionalityConstantY *
                            y1), (int) (x2 // * proportionalityConstantX
                            ), (int) ( // proportionalityConstantY *
                            y2));
                }
            }
        }
        // g.drawOval(paintX, paintY, 30, 30);
    }

    public void setRoute(IChromosome route) {
        this.route = route;

    }
}
